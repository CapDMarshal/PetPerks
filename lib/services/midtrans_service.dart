import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../services/api_service.dart';
import '../cart/midtrans_payment_screen.dart';

class MidtransService {
  final DataService _dataService = DataService();

  // TODO: Replace with your actual Client Key from Midtrans Dashboard > Settings > Access Keys
  final String midtransClientKey =
      "Mid-client-Py1oDblt2FIwsNHg"; // Example Sandbox Key

  // TODO: Replace with your actual Backend URL that hosts the SNAP token generation logic
  // DO NOT put your Server Key here.
  static const String baseUrl =
      "https://chynoxvrhjyszzbzfufj.supabase.co/functions/v1/smooth-service";

  /// Initiates the Midtrans payment flow
  Future<void> initiatePayment(BuildContext context,
      {required double amount}) async {
    try {
      // 1. Create Order with 'pending_payment' status
      // This ensures we have an Order ID to associate with the transaction
      final orderId = await _dataService.submitOrder(
          status: 'pending_payment', paymentMethod: 'Midtrans');

      if (!context.mounted) return;

      // 2. Get Snap Token
      // CRITICAL: This MUST be generated by your backend using your Server Key.
      // Calling Midtrans API from client side with Server Key is NOT SECURE.
      final snapToken = await _getSnapTokenFromBackend(orderId, amount);

      if (!context.mounted) return;

      // 3. Navigate to Payment Screen
      final result = await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => MidtransPaymentScreen(
            snapToken: snapToken,
            clientKey: midtransClientKey,
          ),
        ),
      );

      // 4. Handle Result
      if (result != null) {
        // Result is a JSON object from Midtrans Webview
        // Example: {transaction_status: settlement, ...}
        final status = result['transaction_status'];

        if (status == 'settlement' || status == 'capture') {
          // Success
          await _dataService.updateOrderStatus(orderId, 'paid');
          // NOTIFICATION TRIGGER
          await _dataService.addNotification(
            title: 'Payment Successful',
            message: 'Your order #$orderId has been paid successfully.',
            type: 'order',
          );

          _showSuccess(context, 'Payment Successful!');
          // Navigate to success screen or Orders
        } else if (status == 'pending') {
          await _dataService.addNotification(
            title: 'Payment Pending',
            message: 'Your order #$orderId is pending payment.',
            type: 'order',
          );
          _showSuccess(context, 'Payment Pending...');
        } else {
          // Failed/Cancelled
          // Optionally update order to 'cancelled'
          await _dataService.updateOrderStatus(orderId, 'cancelled');
          await _dataService.addNotification(
            title: 'Payment Failed',
            message: 'Payment for order #$orderId failed or was cancelled.',
            type: 'order',
          );
          _showError(context, 'Payment Failed or Cancelled');
        }
      } else {
        // User closed without finishing (Back button)
        // Order remains 'pending_payment'
      }
    } catch (e) {
      if (context.mounted) {
        _showError(context, 'Payment Error: $e');
      }
    }
  }

  Future<String> _getSnapTokenFromBackend(String orderId, double amount) async {
    try {
      final response = await Supabase.instance.client.functions.invoke(
        'smooth-service',
        body: {
          'orderId': orderId,
          'amount': amount,
          // action defaults to token generation if omitted
        },
      );

      final data = response.data;
      final token = data['token'];

      if (token == null || token.toString().isEmpty) {
        throw Exception("Token missing from backend response: $data");
      }

      return token.toString();
    } catch (e) {
      print("Error calling Supabase Function: $e");
      rethrow;
    }
  }

  /// Checks the transaction status from Midtrans via Backend
  /// Returns the new status string (e.g., 'paid', 'pending_payment', 'cancelled')
  Future<String?> checkTransactionStatus(String orderId) async {
    try {
      final response = await Supabase.instance.client.functions.invoke(
        'smooth-service',
        body: {
          'orderId': orderId,
          'action': 'check_status',
        },
      );

      final data = response.data;
      if (data != null && data['status'] != null) {
        return data['status'].toString();
      }
      return null;
    } catch (e) {
      print("Error checking transaction status: $e");
      return null;
    }
  }

  void _showError(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message), backgroundColor: Colors.red),
    );
  }

  void _showSuccess(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message), backgroundColor: Colors.green),
    );
  }
}
